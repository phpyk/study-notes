# 8.散列表（中）
### 散列表碰撞💥攻击
构造数据，是所有的数据经过hash function之后，都散列到同一个槽里，如果使用的是基于链表的冲突解决方法，散列表就会退化为链表，查询的时间复杂度会从O(1)变为O(n)
例如：散列表有10w数据，查询100次需要0.1秒，退化后需要1w秒，查询操作就会消耗大量CPU，导致系统无法响应

### 如何设计散列函数
* 不能太复杂，影响性能
* 生成的值要尽可能随机并且均匀分布，这样才能避免或最小化散列冲突

### 装载因子过大
装载因子过大会导致频繁发生散列冲突，查询、插入操作变慢，装载因子设置为某个值，超过或低于这个值，则进行动态扩容或缩容

### 如何避免低效的扩容
当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。
为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。
当有新数据要插入的时候，新散列表中插入数据，并从老的散列表中取一个数据插入新散列表，每次插入都重复此过程，老的散列表中的数据就一点一点全部搬移到新散列表中了。
这期间的查询操作，为了兼容新老散列表的数据，可以先从新表查，查不到再从旧表查

### 冲突解决方法优劣势
1. 开放寻址法
优点：序列化简单；数据都存在数组中，可利用cpu缓存加快查询速度
缺点：删除数据时比较麻烦；冲突代价更高，装载因子不能设置太大（小于1），比较浪费空间

**数据量比较小，装载因子小的时候，适合用开放寻址法，java中的ThreadLocalMap就是用的开放寻址法解决散列冲突的**

2. 链表法
优点：内存利用率高，装载因子可以设置的大一些
缺点：链表要存储指针，比较消耗内存，且链表结点不连续，不能利用CPU缓存

**适合存储大对象，大数据量的散列表，比开放寻址法更加灵活，链表可以用红黑树、跳表代替**

### 工业级的散列表：Java中的HashMap
* 初始大小默认16，可以修改
* 最大装载因子默认0.75，超过0.75自动扩容为两倍大小
* 用链表法解决冲突，链表长度超过8，链表会转为红黑树，少于8红黑树又会转为链表

### 思考题
在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？
redis的Hash