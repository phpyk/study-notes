# 7.散列表（上）
散列表(Hash Table) 用的就是数组按照下标随机访问的时候，时间复杂度是O(1)的特性。
hashTable的key是用过散列函数映射为数组的下标，然后将value存储在下标中的位置。

### 散列函数(hash function)
设计要求：
	* 散列函数计算得到的散列值是一个非负整数；（因为数组下标是从0开始）
	* 如果 key1 = key2，那 hash(key1) == hash(key2)；
	* 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。（避免散列冲突）

### 装载因子
> 散列表的装载因子 = 填入表中的元素个数 / 散列表的长度  

### 散列冲突
避免散列冲突的方法：开放寻址法，链表法
1. 开放寻址法
如果出现了散列冲突，就重新探测一个空闲位置，包含以下几种寻址方法
* 线性探测
插入：当插入数据时，key经过hash()函数，生成一个元素的下标idx，如果数组这个下标下已经有数据了，说明产生了散列冲突，这时从这个idx往后遍历数组，如果找到了空闲位置，则插入数据，如果没有空闲位置，则从头遍历，知道找到空闲位置为止。
查找：跟插入类似，也是遍历数组，比对数组的元素和要找的元素，如果相等则返回，如果遍历到数组中的空闲位置，还没有找到，则说明不在散列表中
删除：将要删除的元素，标记为deleted，暂时不删除

* 二次探测
线性探测每次探测步长为1，二次探测的步长为2的n次方，探测的下标序列
hash(key)+0, hash(key)+2, hash(key)+4 …
* 双重散列
不只使用一个hash function,使用一组函数，hash1(key), hash2(key), hash3(key) …
依次类推，知道找到空闲的存储位置。

2. 链表法
当遇到散列冲突时，将冲突的值放在一个链表里
插入：遇到散列冲突时，插入对应链表即可，时间复杂度O(1)
删除：同上
查找：遍历对应的链表即可

### 思考题
1. Word文档中的单词拼写检查是如何实现的？
常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，用散列表存储整个英文单词词典。
当用户输入某个英文单词时，拿用户输入的单词去散列表中查，如果查到，则拼写正确，如果没查到，说明拼写可能有误，给予提示。

2. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
遍历10万条URL，将hash(url)得到散列表的key，散列表的value存储访问次数，遍历完成后得到一个key=hash(url)，value=access_count的散列表，将散列表的value排序即可。
为防止出现散列冲突，value中可以存储一个对象，对象包含url,key,access_count属性，出现冲突时，用链表法解决。
![](https://kkhungry-1252400385.cos.ap-shanghai.myqcloud.com/B491BC96-6D8E-44FB-82CE-F097CEC8FF0D.png)

3. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？
以数组A构建散列表，key为字符串，value为出现次数。
再遍历数组B，以字符串为key在散列表中查找，如果value > 0，说明此字符串AB中都存在。
时间复杂度O(n)
考虑散列冲突的情况：value存储一个对象，包含字符串str,出现次数count属性，用链表法存储，
两个数组都遍历完成后，遍历散列表，找出链表长度>1的value，再挨个比对对象的str字段