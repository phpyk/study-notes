# TCP/IP网络模型

### TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，自上而下分别是：

* 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。
* 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。
* 网络层：负责路由以及把分组报文发送给目标网络或主机。
* 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。

## TCP三次握手-建立连接
![](https://kkhungry-1252400385.cos.ap-shanghai.myqcloud.com/8552C04B-87E6-46DD-BD99-71E1A7B6F415.png)

概念解释：
ACK：此标志表示应答域是否有效。0无效，1有效
SYN：表示同步序号，用来建立连接，和ACK搭配使用，当发送请求时：SYN=1,ACK=0，当收到请求时：SYN=1,ACK=1
seq：顺序号码，TCP协议传输时时按顺序接收的

三次握手步骤：
1. 客户端发出建立连接的请求，并发送一个顺序号码 SYN=1,seq=x
2. 服务器接收到请求后，返回SYN=1,ACK=1标明接收到了此请求，返回ack=x+1标明此次应答是对序号为x的请求所作出的应答，同时发送一个序号为y的请求，用来检查客户端是否能收到。
3. 客户端接收到序号为y的请求后，发出ACK=1标明接收成功，ack=y+1表明是对序号为y的请求的应答，seq=x+1表示对seq=x的请求建立连接

### 为什么要三次握手而不是两次？
1. 个人理解：第一次握手验证客户段能否正常发送请求，第二次验证服务端能否正常应答和发送，第三次验证客户端能否正常应答
2. 防止服务端一直等待而浪费资源
谢希仁《计算机网络》第四版中讲：三次握手的目的是防止已失效的连接请求报文突然又传到了服务端，因而产生错误。
《计算机网络》中的例子🌰：
“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

## TCP四次挥手-关闭连接
![](https://kkhungry-1252400385.cos.ap-shanghai.myqcloud.com/D48BB50D-11F9-4276-BADD-19A26FD3132A.png)

概念解释：
FIN：（finish）终结，用来释放一个连接，当FIN=1时，表明此报文段的发送方数据已经发送完毕，并要求释放连接。
MSL：Maximum Segment Life消息最大存活时间，去向ACK消息的最大存活时间（MSL）+来向FIN消息的最大存活时间（MSL）=2MSL，Linux定义的TCP_TIMEWAIT_LEN=60s，所以1MSL=30s [github.com/linux/tcp](https://github.com/torvalds/linux/blob/c839682c719f0e3dc851951c9e2eeb8a41cd9609/include/net/tcp.h#L120)
四次挥手步骤：
1. 客户端（也可以是服务端）向服务端发送FIN信号📶，序号seq=u，表示需要关闭连接
2. 服务端（也可以是客户端）收到FIN信号后，返回“我已收到关闭请求，但还没准备好（数据还没传送完毕），请继续等我消息”
3. 服务端发送FIN=1（数据已传送完成）ACK=1，ack=u+1（表示是对ac=u的应答，且应答有效），seq=w（检验是否能收到这条应答）
4. 客户端收到FIN信号后，进入TIME_WAIT状态，同时回复服务端“我已收到，你可以关闭了”
5. 服务端收到应答ACK后关闭连接，客户端等待2MSL后，依然没有收到回复表明服务端已正常关闭，ok，那我客户端也可以关闭了
